# 代码改进方案

## 改进1：SSH连接增加重试机制和容错

### 问题
当前SSH连接超时后立即失败，在网络不稳定时会导致大量失败。

### 改进方案
在 `_ssh_run` 函数中添加重试机制，并增加超时时间。

```python
def _ssh_run_with_retry(
    command: str, 
    *, 
    timeout: int = 900, 
    description: str | None = None,
    max_retries: int = 3,
    retry_delay: int = 5
) -> SSHResult:
    """Execute command with retry mechanism for unstable networks."""
    
    last_error = None
    for attempt in range(1, max_retries + 1):
        try:
            return _ssh_run(command, timeout=timeout, description=description)
        except DeploymentError as exc:
            last_error = exc
            if attempt < max_retries:
                log_warning(f"⚠️ SSH命令失败（尝试 {attempt}/{max_retries}）：{exc}，{retry_delay}秒后重试…")
                time.sleep(retry_delay)
            else:
                log_error(f"❌ SSH命令在 {max_retries} 次重试后仍失败：{exc}")
    
    raise last_error
```

## 改进2：增加SSH超时时间

### 修改位置
`main.py` 第516行，将 `ConnectTimeout=30` 改为 `ConnectTimeout=60` 或更长。

```python
"-o", "ConnectTimeout=60",  # 从30秒增加到60秒
```

同时修改 `_ensure_paramiko_client` 中的超时：
```python
timeout=60,  # 从30秒增加到60秒
```

## 改进3：改进部署监控逻辑

### 问题
当前监控逻辑在网络不稳定时频繁失败，导致无法获取状态。

### 改进方案
1. 增加检查间隔（从15秒增加到30-60秒）
2. SSH失败时不立即失败，而是记录并继续
3. 使用文件锁判断部署完成

```python
# 在 prepare_wireguard_access 函数中修改
check_interval = 30  # 从15秒增加到30秒，网络不稳定时增加到60秒

# 修改检查逻辑，增加容错
try:
    pid_result = _ssh_run_with_retry(
        check_pid_cmd, 
        timeout=20,  # 增加超时时间
        description="检查进程ID",
        max_retries=2  # 允许重试2次
    )
    pid = pid_result.stdout.strip()
except DeploymentError as exc:
    # SSH失败时不立即失败，而是记录并继续等待
    if check_count % 4 == 0:  # 每2分钟才显示一次错误
        log_warning(f"  ⚠️ [{elapsed}秒] 无法检查状态（网络可能不稳定）：{exc}，继续等待…")
    time.sleep(check_interval)
    continue
```

## 改进4：彻底禁用NVIDIA驱动

### 修改位置
`deploy_wireguard_remote_script` 函数中的脚本生成部分。

在apt安装前添加更彻底的禁用逻辑：

```bash
# 在脚本开始处，apt-get update 之前添加
log "彻底禁用NVIDIA驱动自动安装"
# 标记所有NVIDIA相关包为hold，防止自动安装
apt-mark hold nvidia-driver-* libnvidia-* 2>/dev/null || true
# 禁用NVIDIA驱动的post-install脚本
if [ -f /usr/lib/nvidia/post-install ]; then
    chmod -x /usr/lib/nvidia/post-install || true
    mv /usr/lib/nvidia/post-install /usr/lib/nvidia/post-install.disabled 2>/dev/null || true
fi
# 设置环境变量
export NVIDIA_INSTALLER_OPTIONS="--no-questions --accept-license --no-backup --skip-depmod --no-nvidia-modprobe"
export NVIDIA_DRIVER_SKIP_INSTALL=1
export NVIDIA_AUTO_INSTALL=no
# 在apt安装时跳过推荐包
apt_retry "安装 wireguard 及相关组件" apt-get install -y --no-install-recommends \
  wireguard wireguard-tools qrencode iptables-persistent netfilter-persistent curl
```

## 改进5：添加代理支持

### 方案A：通过环境变量支持SSH代理

在 `_ssh_run` 函数中添加代理支持：

```python
def _ssh_run(command: str, *, timeout: int = 900, description: str | None = None) -> SSHResult:
    """Execute command with optional proxy support."""
    
    ctx = _require_ssh_context()
    ssh_executable = shutil.which("ssh")
    
    # 检查是否有代理配置
    ssh_proxy = os.environ.get("SSH_PROXY", "").strip()
    proxy_command = None
    if ssh_proxy:
        # 支持格式：user@host:port 或 host:port
        if "@" in ssh_proxy:
            proxy_command = f"ssh -W %h:%p {ssh_proxy}"
        else:
            # SOCKS代理
            proxy_command = f"nc -X 5 -x {ssh_proxy} %h %p"
    
    ssh_cmd = [
        ssh_executable or "ssh",
        "-i",
        str(ctx.key_path),
        "-o",
        "BatchMode=yes",
        "-o",
        "StrictHostKeyChecking=accept-new",
        "-o",
        "ServerAliveInterval=30",
        "-o",
        "ServerAliveCountMax=10",
        "-o",
        "ConnectTimeout=60",  # 增加超时
    ]
    
    # 如果有代理，添加ProxyCommand
    if proxy_command:
        ssh_cmd.extend(["-o", f"ProxyCommand={proxy_command}"])
    
    ssh_cmd.extend([
        f"root@{ctx.hostname}",
        command,
    ])
    
    # ... 其余代码保持不变
```

### 使用方法
设置环境变量：
```powershell
$env:SSH_PROXY="user@proxy_server:22"  # SSH代理
# 或
$env:SSH_PROXY="127.0.0.1:1080"  # SOCKS代理
```

## 改进6：优化错误处理

在部署监控中，当SSH失败时不要立即抛出异常，而是记录并继续：

```python
# 在 prepare_wireguard_access 的监控循环中
consecutive_failures = 0
max_consecutive_failures = 10  # 允许连续失败10次

while time.time() - start_time < max_wait_time:
    try:
        # ... 检查逻辑 ...
        consecutive_failures = 0  # 成功时重置计数器
    except DeploymentError as exc:
        consecutive_failures += 1
        if consecutive_failures >= max_consecutive_failures:
            # 连续失败太多次，可能网络完全不可用
            log_error(f"❌ 连续 {max_consecutive_failures} 次检查失败，网络可能完全不可用")
            raise DeploymentError(f"网络连接不稳定，无法完成部署检查：{exc}") from exc
        
        # 记录错误但继续等待
        if check_count % 4 == 0:  # 每2分钟显示一次
            log_warning(f"  ⚠️ [{elapsed}秒] 检查失败（{consecutive_failures}/{max_consecutive_failures}）：{exc}，继续等待…")
    
    time.sleep(check_interval)
```

## 实施建议

1. **立即实施**：改进2（增加超时时间）- 最简单，风险最低
2. **短期实施**：改进1和6（重试机制和错误处理）- 提高稳定性
3. **中期实施**：改进3（监控逻辑优化）- 减少资源浪费
4. **长期实施**：改进4（NVIDIA驱动禁用）和改进5（代理支持）- 解决根本问题

## 测试建议

1. 在本地网络不稳定时测试重试机制
2. 测试代理功能是否正常工作
3. 验证NVIDIA驱动是否被正确禁用
4. 测试长时间部署监控是否稳定

